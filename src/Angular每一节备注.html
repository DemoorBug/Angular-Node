<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>node-mongodb建站</title>
<style type="text/css">
*{padding:0;margin:0;font-size:24px;font-family:'微软雅黑';background:#f7f7ff}script{display:none}body{padding-left:20px}strong{display:inline-block;padding:5px 130px;margin:0 auto;text-align:center;background:#02a2bd;color:#fafffa;border:1px dotted #CCC}i{display:inline-block;font-style:normal;font-weight:bolder;color:red;background:#FFF;padding:5px 6px}b{display:inline-block;font-style:normal;font-weight:bolder;color:green;background:#FFF;margin:5px 0;padding:5px 6px;border-top:1px dotted #CCC;border-bottom:1px dotted #CCC}a{display:inline-block;font-style:normal;text-decoration:none;font-weight:bolder;color:blue;background:#FFF;margin:5px 0;padding:5px 6px;border-top:1px dotted #CCC;border-bottom:1px dotted #CCC;cursor:pointer}ul{list-style:none;text-align:center}ul li{display:inline-block}ul li a{float:left;font-size:16px;color:green}.c{position:fixed;right:50px;bottom:20px;height:50px;width:50px;text-align:center;line-height:40px;border:0}u{display:inline-block;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:10px solid green;background:0}sup{font-size:14px;background:0}em{overflow:hidden;height:29px;cursor:pointer}em,em i,em b{margin:10px;border-radius:4px;background-color:#FFF;padding:10px;font-size:13px;display:block;font-style:normal}em i,em b{font-size: 20px; padding: 10px 0;margin: 0}pre{background: #eee;font-size: 12px !important;padding: 20px;}
</style>

</head>
<body>
<ul></ul>
<strong>置顶</strong>
数据绑定：当js中的变量改变时，他会自动更新自己所影响的试图模型，原来是这样，so
ng-change  input发生改变，则触发
ng-click  点击触发
ng-repeat(重要): 用来将数据集合按照指定的形式重复渲染出来 详见table.html:38
<i>这里记录下我理解的构造函数和工厂方法</i>
构造函数： 就是里面可以this.方法
工厂： 就是利用ruturn返回一个对象键值对
厉害了 哈哈哈哈
<i>你总是这样轻言放弃的话，无论多久都只会原地踏步   不管知识有多新 只要来了什么姿势都得上</i>
<i>人的一切痛苦, 本质上都是对自己无能的愤怒</i>
<i>努力加油，只为家人过的更好</i>
<b>CORS原来也算一次请求，请求成功后res.send()一下，哈哈，好厉害啊</b>
<a>http://www.ruanyifeng.com/blog/2016/04/cors.html</a>
<em>
var em = document.getElementsByTagName('em')
for (var i=0;i&lt;em.length;i++){
 em[i].style.height='auto'
}
</em>


<strong>动画(四)：在自定义指令中使用动画</strong>
<em>$animate

</em>

<strong>AngularJS实现JS动画</strong>
<em>app.animation(classname,animateFun)
app.animation('.fade',function(){
  return {
    enter: function(element,done){//done 当动画结束时调用done
      //定义并允许动画
      //当动画结束时调用done

      //也可以返回终止函数
      return function(cancelled){
        //关闭或者取消动画的回调函数
      }
    }
  }
})

<b>js动画 很烂 居然还要引入jquery</b>

</em>

<strong>AngularJS高级</strong>
<em>
动画：CSS3动画、javascript动画、
CSS3 动画
  过渡 transition
  动画 animation
AngularJS 对CSS3动画的支持
  引入动画模块 angular-animate.js
  添加依赖ngAnimate
  触发的特别事件：ng-[event]-[active]
  animate/enter/enter-active/leave/leave/lave-active

ng-if ng-show

ng-view

ng-hide/ng-show指令动态样式：ng-hide
指令包括：ngIf ngView ngShow ngHide ngSwitch ngRepeat ngInclude
<b>除了ngShow ngHide其他 都一样 ngRepeat 有3个事件</b>
ngRepeat: 除enter和leave事件，还有一个move

</em>
<strong>路由监控以及过滤器</strong>
ng-repeat
{{$index}},索引
{{$first}},第一个
{{$middle}},中间
{{$last}},最后
{{$even}},偶数
{{$odd}},奇数
<em>路由监控
定义初始化方法app.run()
监听路由变化开始事件$routeChangeStart
如果要跳转的页面不是登录页则必须验证其登录角色
6.角色名称过滤器
定义一个过滤器n
  roleName
引入过滤器
修改users.html
</em>
<strpng>项目实战(三)：完成用户模块管理</strpng>
<em>创建用户管理模块：
顶部导航栏views/nav.html
用户管理页面 views/users.html
UsersController
</em>

<strong>项目实战(二)</strong>
<em>项目：教学系统
需求分析：
  用户管理(管理员role=1、教师role=2、学生role=3)users.html
  班级管理(教师管理班级)classes.html
  考试系统(编辑考卷、考试系统、评卷系统、统计系统)exams.html
  教师课时记录和统计系统
  点名、考勤系统
  。。。
<b>项目架构</b>
Bootstrap: 响应式CSS布局框架

具体实现
  项目配置:
    配置路由
    配置resuangular
  实现登陆页面
    页面login.html
    实现控制器LoginController
    实现UserService
</em>


<strong>项目实战(一):数据库MongoDB</strong>
<em>MongoDB - noSQL 不需要去写sql语句的
下载: www.mongodb.org 网站
如果运行的版本是Windows Server 2008 R2 或Windows 7 ,请安装修复程序解决内存映射文件在windows的问题。
  下载地址: https://support.microsoft.com/zh-cn/hotfix/kbhotfix?kbnum=2731284&kbln=zh-cn
创建数据存储目录： c:/data/db/
测试连接:
  设置环境变量
  启动服务：cmd-mongod

Mongoose : object document mapper  对象文档映射(ODM);

安装: npm install --save mongoose

使用mongoose

范例: 使用Mongoose
1.创建Express项目： mongoose-test
  -express mongoose-test
  -cd mongoose-test
  -npm install --save mongoose
2.添加mongoose依赖:
  -npm install --save mongoose
3.修改routers/users.js

</em>


<strong>项目架构</strong>
<em>目录结构:
angular-test/
  images/ - 存放图片素材
  style/ - 存放样式
  libs/ - 存放库文件
  scripts/ - 业务逻辑相关的文件
    app.js - 主文件 入口文件
    config/ - 配置文件
    controllers/ - 控制器
    directives/ - 指令
    filters/ - 过滤器
    services/ - 服务
  views/ - 模板文件
  test/ - 测试文件
<b>模块化</b>
</em>


<strong>依赖注入</strong>
<em>依赖注入是一种设计模式，它可以去除对依赖关系的硬编码，从而可以在运行时改变甚至移除依赖关系
优点：使开发者专注于业务逻辑开发;代码更加清晰易维护;易于测试
AngularJs 使用 $injector 来管理依赖关系的查询和实例化;
Angular内部处理过程:
//使用注入器加载应用
var injector = angular.injector(['ng','myApp']);

//通过注入器加载$controller服务

var $controller = injector.get('$controller');
var scope = injector.get('$rootScope').$new();
//加载控制器并传入一个作用域

var myController = $controller('myController',{$scope:scope})
<b>推断式注入声明：AngularJS假定函数中的参数名称就是依赖注入的名称，注入过程如下：</b>
injector.invoke(function($http,greenter){});
只适用于未经压缩和混淆的代码;
跟参数顺序无关
<b>显示注入声明:Angular提供了显示的方法来明确定义一个函数在被调用时需要用到的依赖关系</b>
代码被压缩依然能正常工作；
通过设置函数对象的$inject属性显示注入依赖;
<b>行内注入声明：我自己研究出来了 哈哈哈 </b>
angular.module('myApp',[]).controlls('myController',['$scope','greeter',function($scope,greeter){}])
<b>$injector API:</b>
annotate(fn) : 返回由服务名称组成的数组
<pre>
var injector = angular.injector(['ng','myApp']);

injector.annotate(function($q,greeter){});
//["$q","greeter"]
</pre>
get(name):返回一个服务的实例。拦截器避免循环引用的错误必须这么写
has(name):返回是否包含指定name服务的布尔值；
instantiate(type,locals):可以创建某个JS类型的实例 == new
instantiate(比如一个字符串,传参)

invoke(fn):给函数添加依赖

</em>

<strong>这讲才是重点啊：目的</strong>
<em><b>测试angular应用：路由、页面内容、控制器、服务和工厂、指令、过滤器、模板</b>
可视化的用端到端
逻辑的用  单元测试
<b>控制器测试：</b>
  模拟应用主模块;
  创建控制器和其相关的局部作用域
  基于这个局部作用域来进行测试我们的预期。
<b>服务和工厂的测试：</b>
  模拟应用模块；
  注入服务即可
<b>指令测试</b>
  注入$compile和$rootScope
  把dom元素通过$compile编译，将生成的链接函数执行，传入$rootScope作为参数
  64.测试4：测试AngularJS应用2-2   24分
</em>
<strong>测试angularJs应用</strong>
<em>模拟：在收控环境下定义模拟对象模仿真实对象的行为
AngularJS中实现模拟：angular-mocks.js(专用于单元测试)
  1.添加lib目录，添加angular-mocks.js
  2.修改配置文件karma.conf.js
使用angular.mock.module(moduleName)创建模拟模块对象
  可用module代替angular.mock.module
使用angular.mock.inject(function($roorScope){...})
  可用inject代替angular.mock.inject
  创建变量保存注入的服务，这样可在整个it的字句中使用它们
<b>使用$httpBackend模拟后端实现(仅在单元测试中使用)</b>
  expect(method,url,[data,headers]) : 建立一个请求的期望
    1) method: HTTP请求方法,想GET.POST,PUT.DELETE
    2) url：期望调用的URL或一个函数(接收给定的URL并返回一个标识它是否匹配的布尔值。匹配返回true,否则返回false)
    3) data:请求主体，或者是函数(接收给定的data字符串或对象，并在符合预期时返回true,否则返回false)
    4) header: HTTP头或者函数(接收header对象并在符合预期时返回true，否则返回false)
  flush()：冲刷HTTP请求，清理仍然保持了$httpBackend异步行为的执行环境
<b>最佳实践：</b>
1.$httpBackend.expect 方法有几个帮助函数：expectGET(url)/expectPOST()/expectPUT/expectDELETE()/expectHEAD()/expectJSONP/expectPATCH()
2.要确定每个测试结束时，不会仍有未结束的请求挂起
<pre>
  afterEach(function(){
    $httpBackend.verifyNoOutstandingExpectation(); //清楚多余期望expect
    $httpBackend.verifyNoOutstandingRequest(); 清楚多余请求request
  })
</pre>
3.在一个多阶段测试内部复用$httpBackend的统一实例时要重置所有已设置请求的预期
<pre>
$httpBackend.resetExpectations();
</pre>
  requestHandler:expect方法会返回该对象，它带有一个函数respond,能给模拟的请求建立一个响应，响应有两种形式：
  1) 设置响应代码、数据、响应头，或者全部三项
    比如： respond('200'.'success')
           resoond('fail')
           respond({'X-RESPONSE','Faulure'})
  2) 设置一个请求处理程序，请求成功后执行，这种形式返回包含上面三项数据的数组。
    //respond(function(method,url,data,headers){
      return [200,'data',{header:'header'}];
    })
  <b>when(method,url,[data,headers]): 与expect不同，它没有对请求创建预期，而是给应用创建一个假的后端，返回假数据。使用when()时，每个匹配URL的请求都会被一条when定义处理。用expect时响应不是必须的，但用when的时候响应必须有。</b>

</em>
<strong>测试(一)：使用Karma+Jasmine进行测试</strong>
<em>测试：衡量应用健康度的手段
<b>为什么测试</b>
  1).了解代码各部分是否按预期工作;
  2).更容易定位bug从而解决之;
  3).使其他开发人员更容易上手
  4).风方便、容易的提供应用可用文档
<b>如何测试？</b>
  1).两种测试类型:单元测试(知道代码怎么写的)、端到端的测试(用户的角度)
  2).单元测试：测试隔离的、单独组件的代码
    适用于测试小型、独立代码单元、单个函数或者较小交互功能
  3).端到端测试:对应用做黑盒测试
    从最终用户的角度测试应用，并不关心底层实现。适合测试大型应用的功能
<b>AngularJS中如何开始测试</b>
  工具：Karma+Jasmine
  确保安装了Node.js
  安装测试运行器Karma: npm install -g karma
  构建应用的项目结构：
  app/
    index.html
    lib/ - js库
    js/ - 业务逻辑
    views/ - 试图模板
    test/
      karma.conf.js   - 单元测试配置文件
      karma-e2e.conf.js - 端到端测试配置文件
      lib/  - 模拟库
        angular-mocks.js
      unit/ - 单元测试代码
      e2e/ - 端到端测试代码
<b>配置文件解读</b>
初始化配置文件：karma init karma.conf.js
选择测试框架：jasmine
是否添加 require.js: no
捕获浏览器列表:Chrome,Firefox
测试代码路径： ../js/**/*.js(源文件),unit/**/*.js
排除代码：[]
监视文件变更：true
<b>运行测试：karma start karma.conf.js</b>
<b>编写测试：</b>
  describe(specName,fn): 创建细则套件
  describe('UnitTest:MainController',function(){
    describe('index method',function(){...}) //细则的嵌套
  })
<b>创建细则套件</b>
<pre>
//定义创建细则套件
describe('UnitTest:MainController',function(){
  //定义写着
  it('index method',function(){
    //测试代码
    expect(true).toBe(true);
  })
})
</pre>
<b>最佳实践：</b>
1.使用describe函数把相关细则分组
2.测试命名成可读英文
<b>函数</b>
it(specDesc,fn):定义细则，包含若干测试预期
  it('contains a passing spec',function(){...})
expect(val1).toBe(val2):创建测试预期，val1真实值，toBe()匹配器函数，val2期望值，创建否定式：expect(val1).not.toBe(val2)
匹配器函数：
  toBe(val):相当于全等 ===
  toEqual(val)相当于 ==
  toMatch(RegexOrString):使用正则表达式匹配字符串
  ToBeUndefined(): 将值与undefined比较，差不多就是来比较这个变量是否赋值了
  toBeDefined():与前一个方法相反
  toBeNull(): 将值与null比较
  toBeTruthy(): 将值转换为布尔值与true比较
  toBeFalsy(): 将值转换为布尔值与false比较
  toContain(val): 检测一个条目是否在数组中
  toBeLessThan(val): 比较数值是否小于预期值
  toBeGreaterThan(val): 与上面方法相反
  toBeCloseTo(val,fixed): 比较在一个指定精度级别内真实值是否等于期望值
  toThrow():验证一个函数是否抛出异常
<b>自定义匹配器</b>
1.写在beforeEach(fn)中
2.调用jasmine.addMatchers(obj)
3.自定义匹配器函数返回对象必须实现compare(actual,expected)
4.compare需要返回包含pass属性的对象，其值应当是比较是否成立的判断表达式
<b>安装和拆卸: 在每个测试用例运行之前或者之后被调用</b>
  beforeEach(fn)  初始化
  afterEach(fn)   重置

</em>

<strong>给你一个承诺-Promise</strong>
<em><b>Promise对象</b>
  promise是一种异步方式处理值(或非值)的方法，promise是对象，代表了一个函数最终可能的返回值或抛出异常。在与远程对象交互时，可以吧Promise看做远程对象的一个代理
  为什么要用promise
    使用Promise可以让我们逃脱回调地狱，使代码可以进行链试操作，看起来像是同步的。
    可以在程序中的任何位置捕捉错误，并且绕过依赖于程序异常的后续代码，获得功能组合和错误冒泡的能力，最重要的是保持了异步运行能力
  如何在AngularJs中使用Promise
  1).使用内置服务$q获得deferred对象
  2).通过deferred对象的promise属性获取Promise对象
  3).调用deferred对象的resolve(value)/reject(reason)失败/notify(value)进行了多少，请求条/与Promise对象交互
  4).通过then处理过程或结果
  <b>思考：为什么需要$q,$http不是直接返回Promise对象吗?</b>
1.当做异步操作的时候；并且可能出现回调嵌套;
2.$http内部使用$q方式实现的异步操作。
<b>通过promise对象的then方法进行链试调用</b>
  then(successFn,errorFn,progressFn)
<b>Promise对象常用方法</b>
then(successFn,errorFn,progressFn)
catch(errorFn):帮助方法，可以取代then中的errorFn
finally(callback):无论成功失败，都会执行，适合执行清理任务。
<b>$q服务的其他方法</b>
all(promises);  通常传递数组参数，该方法将多个promise对象合并为一个，如果任意一个promise被拒，则结果promise也会被拒
when(val): 吧一个可能是指或者能接着then的promise包装成一个promise，这样可以处理一个可能是也可能不是promise的对象
<i>这讲有bug 但是老师也没有解决。。我用throw抛出错误，就可以了</i>
<b>我发现了一个算法和数据逻辑  好像可以解释我为什么没有那些理解逻辑</b>
</em>

<<strong>用户认证与授权</strong>
<em><b>使用路由定义受保护的资源</b>
根据用户权限控制试图访问
通过访问级别定义路由
通过$routeChangeStart事件控制路由
<a>routeUser/index.html</a>
使用到了cookie  我基本没用过。
<b>本讲设计知识：</b>
$routeProvider  路由设置
$httpProvider.interceptors.push('AuthInterceptor');  注册拦截器
$location.path() 跳转
app.constant()　 常量设置 优点可以注入
app.run() //run方法触发全局事件的处理和监听行为  赶紧和$(function(){}) 类似
$routeChangeStart  事件 //evt 好像是自己本身。没有用到, next为将要跳转视图对象,curr是当前视图对象
$rootScope  注入  根
$injector  注入  这个好像可以把其他server 注入进来
app.factory()  工厂server
$cookieStore  cookie注入
</em>

<strong>用户认证与授权</strong>
<i>多数网络应用都是有需要保护的资源，这些资源只能由可以被识别且信任的授权用户访问</i>
<b>保护客户端应用的两种方法：服务端视图渲染和客户端身份验证</b>
<em>客户端身份验证：
重定向未经身份验证的请求;
捕获所有响应码为200的请求，并进行相对应的处理；
在整个页面绘画中持续监听用户身份证验证的情况。
<b>实现重定向行为：</b>
方法1：定义请求拦截器
</em>
<a>users/index.html</a>
因为没有解决auth跨域通过预检测，所以目前只能放到同源的地方玩，，哎，好坑啊

<strong>跨域和同源策略</strong>
<em>浏览器在全局层面禁止了页面加载或执行了与自身来源不同的任何脚本
浏览器通过对页面和资源的协议、主机名和端口号
<b>同源策略允许页面从同一个站点加载和执行特定脚本</b>
解决策略：
  JSONP:是一种绕过浏览器安全限制的数据请求方法
  CORS(cross Origin Resource Sharing)
  服务器代理
<b>JSONP</b>
  添加script标签到DOM并由浏览器接管并向src指定的地址发送一个GET请求取代XHR.它会返回js函数并由请求回调函数调用之
  angular中JSONP：
    $http.jsonp(url?callback=JSON_CALLBACK).success(...)
  生成的script:
    script src= "url?callback=angular.callbacks._0" type="text/javascript"
  响应内容：
    angular.callbacks._0({'data':[{'name':'tom'}]})
代码示例！：
angular
$http.jsonp('http://localhost:3000/jsonp?callback=JSON_CALLBACK')
  .success(function(data){
    console.log(data)
  });
Node
router.get('/jsonp',function(req,res){
  //返回jsonp响应
  res.jsonp({status:'jsonp'});
})
  问题：
  1.需要服务器的支持
  2.安全风险
  3.脚本异常难以处理  没有error回调？
  4.只能处理get请求
<b>CORS 跨域资源共享</b>
  是W3C指定的取代JSONP的标准方式
  CORS 规范扩展了标准XHR对象，允许JS发送跨域的XHR,通过与检查(preflight)机制确认是否有权限向目标服务器发送请求。
  预检查可让服务器接收或拒绝来自全部服务器、特定服务器或一组服务器的请求，这需要客户端和服务端协同工作
  angular中使用CORS:
    客户端：使用config()进行全局配置   新版的angular就不用配置了
      app.config(function($httpProvider){
        //启用xDomain
        $httpProvider.defaults.useXDomain = true;
        //确认移除'x-Requested-With'请求头
        delete $httpProvider.defaults.headers.common['X-Requested-With'];
      })
  <i>CORS 只需要后台配置，前天没有任何区别</i>
  <b>服务端配置：</b>
    必须在响应中假如访问控制的相关头：
    1.Access-Control-Allow-Origin
    res.setHeader('Access-Control-Allow-Origin',req.headers.origin);
    2.Access-Control-Allow-Credentials(可选)：默认情况下CORS请求不会包含cookie，如果服务器返回了这个头，客户端就必须将withCredentials设置为true,否则请求失败，反之亦然。
    必须处理于检查的请求
    res.setHeader('Content-Type','application/json;charset=utr-8')
<b>Node配置：</b>
//加入一个options请求处理方法
router.options('/',function(req,res){
  //设置为请求域或*
  res.setHeader('Access-Control-Allow-Origin',req.headers.origin);
  //设置允许请求
  console.log(req.headers.origin)
  res.setHeader('Access-Control-Allow-Methods','GET,POST,PUT,DELETE,OPTIONS');
});

<b>restangular请求地址</b>
//设置基础URL避免出现404问题
Restangular.setBaseUrl('http://localhost:3000/');
//方案2 利用allUrl(route,url) 获取主Restangular对象
var User = Restangular.allUrl('users','http://localhost:3000/users')
<b>CORS请求分为简单和非简单两种类型，简单类型并不需要与检测，而后者则可能需要</b>
简单请求包括：
  HEAD/GET/POST
  除了Accept、Accept-Language、COntent-Language、Last-Event-ID Content-Type(表单中三种基本类型)以外没有其他请求头
不符合简单请求标准的都是非简单请求
  预检查： OPTIONS类型请求，包含以下头信息：
    Access-Control-Request-Method:请求所使用的方法
    Access-Control-Request-Headers: 逗号隔开的非简单头列表，如果这里设置了，则相应中也必须设置该头

<i>看了下闭包和call apply用法，闭包就是可以访问函数内部的一个变量。call和apply区别就是一个可以第二个接收方式不同罢了call(obj,,,,) apply(obj,arguments),第二个值是一个对象罢了，当然arguments放到函数里面才可以使用，接收所有参数.还有看到了第二讲跨域同源策略4分钟</i>
<a>users/index.html</a>
因为没有解决auth跨域通过预检测，所以目前只能放到同源的地方玩，，哎，好坑啊

</em>

<strong>与服务器通信(十)：使用Restangular</strong>
<a>$http/restangular.html</a>
<a>$http/restangular/index.js</a>
<em>Restangular通过完全不同的途径实现了XHR通信，弥补了$http和$resource内置服务的一些缺点，主要优点如下：
  支持promise: 使用起来符合angularjs习惯并支持链试操作
  promise展开：可以同时操作promise对象
  简单明了的API
  全HTTP方法的支持
  忘记URL:不需要提前指定URL(出了基本URL之外)
  资源嵌套：Restangular可以直接处理嵌套资源，无需创建新的实例
  单例：使用过程中仅需创建一个Restangular资源对象实例
安装：
  下载Restangular：https://github.com/mgonto/restangular
  下载依赖 Lo-Dash(或underscore)
  引入以上两个js文件
  添加依赖：restangular
  注入服务： Restangular
<b>使用</b>
  创建Restangular主对象：
    Restangular.all('accounts');//url:/accounts/
    Restangular.one('accounts',1)//url:/accounts/1
    Restangular.saveral('accounts',1,2,3)//得到一个集合
  GET LIST
  var baseAccounts = Restangular.all('accounts');
  baseAccounts.getList().then(function(accounts){数据处理});
  GET LIST2简写形式
  $scope.accouts = Restangular.all('accounts').getList().$object;
  POST-CREAT
  baseAccounts.post(newAccount);
  GET-ONE /account/1
  Restangular.one('accounts',1).get().then(function(){});
<b>范例：使用主对象查询并维护用户数据</b>
20分
</em>
<strong>与服务器通信(九)：配置$resource</strong>
<em>自定义$resource方法：设置$resource第三个参数对象
  1) $resource(url,{},{})
     $resource(url,{},{
        'update': {method: 'PUT'}
     })
  2) 附加属性：资源有两个属性可以同底层数据定义交互
     $promise: 为$resource生成的原始promise对象，特别用来同$routeProvider.when()在resolve时进行连接
     $resolved: 服务器首次响应时被设置为true
  3) 配置对象：
    $resource(url,{},{
        'update': {method: 'PUT'},
        'get': {
          isArray: true //以数组的形式返回结果，否则就会报异常，等同于query
          interceptor: {//设置拦截器，此处只能设置两个拦截器，响应和响应错误，response和responseError
            response : function(){}
            responseError : function(){}
          }

        }
     })
</em>

<strong>与服务器通信(七)</strong>
<i>本节使用到了node创建服务，所以有些文件避免重复修改，全部存放到$http/config目录</i>
<em>基于非GET方法的HTTP方法：
  save(params,payload,successFn,errorFn) POST方法 保存的意思
  delete(params,payload,successFn,errorFn) DELETE方法
  remove(params,payload,successFn,errorFn) DELETE方法
  delete和remove功能完全相同，remove是IE中的替代方法
搭建测试环境Node.js 单线程高并发  4.2
  安装node.js + git
  安装Express
  安装Express生成器：npm install -g express-generator
  创建Express 项目并启动：
    express restful-test
    cd restful-test && npm install
    npm start
  测试项目：浏览器输入localhost:3000
  编写RESTful API:


</em>

<strong>与服务器通信(六)</strong>
<a>$http/js/resource.js</a>
<em>Restful类型的API调用:Representational State Transfer(表征状态转移)

AngularJs提供$resource服务可以同支持RESTful服务器端数据源来进行交互

使用$resource
  引入相关angular-resource.js
  添加依赖ngResource
  获取资源实例： $resource('data/:name.json',{name:'@username'})
  基于GET的HTTP方法：
    get(params,successFn,errorFn)
      get方法可以不需要设置回调函数
    query(params,successFn,errorFn)
    get和query的唯一不同是Angular期望query返回的是数组


</em>


<strong>与服务器通信(五)</strong>
<a>$http/js/http.js</a>:6-39
<em>设置$httpProvider
  修改默认的Content-Type:application/json
  设置默认缓存
  拦截器：在任何请求发送给服务器之前或者从服务器返回时对其拦截，从而为请求添加一些全局的功能。
    场景：身份验证、错误的处理等
    拦截器的类型：request、response、requestError、responseError
  创建拦截器：1、创建拦截器工厂服务；2、注册该服务
</em>

<strong>与服务器通信(四)</strong>
<em>缓存HTTP请求
1) 设置配置对象cache为true即可
2) 自定义缓存实例，通过$cacheFactory服务获取缓存实例
  a) LRU(Least Recent Used) 最近最少使用原则
  b) 创建： var lru = $cacheFactory('lru',{capacity:20});
  c) 缓存对象可以使用的方法：
    i) info() 获取缓存对象信息
    ii) put(key,value) 存放数据
    iii) get(key) 获取数据
    iv) remove(key) 删除对应key的项
    is) removeAll() 删除所有项
    v) destroy() 摧毁所有
</em>

<strong>与服务器通信(三)</strong>
<em>post和put数据的接收
php接收： $_POST['username'],$_REQUEST['username']
  *由于Content-Type:application/json
  解决方案：修改后台接收参数的方式如下：
  json_decode(file_get_contents('php://input'),true)
  <i>根本不懂。还是等后面讲angular修改头吧，这样感觉好麻烦呀</i>
</em>

<strong>与服务器通信(二)</strong>
<em>$http设置对象：
1) method: 请求的HTTP方法
  a) get post put delete jsonp head
2) url: 目标地址，绝对或相对路径
3) params: 添加URL参数时设置该对象
    <a>$http/js/http.js</a>:37
4) data: 通常发送post请求，设置参数用
5) xsrfHeaderName: cross site request forgery (跨站请求伪造的名称)
6) xsrfCookieName: cross site request (跨站请求伪造cookieName)
7) cache: 可以设置布尔型或缓存对象，如果被设置为true，则会用默认的$http缓存来对get请求进行缓存，如果cache被设置为一个缓存对象$cacheFactory对象的实例，该对象会被用来进行缓存
8) timeout: 设置数值或promise对象，如果是数值，则延迟指定的毫秒数在发送请求，如果promise，那么如果promise对象被查询数据时resolve()，则当前请求会被终止
9) withCredentials: 设置布尔值，CORS跨域资源共享，解决jsonp，默认情况下CORS请求不会发送cookie，所以如果设置true，则就会将目标域的cookie包含在请求中
10) responseType: 指定字符串，
  a) ""
  b) arraybuffer 数组缓存
  c) blob 二进制大数据
  d) document http稳定
  e) json json字符串
  f) text 纯文档
  g) moz-blob firefox接收进度事件
  h) moz-chunked-text 文本流
  i) moz-chunked-arraybuffer ArrayBuffer流
</em>

<strong>与服务器通信(一)</strong>
<a>$http/http.html</a>:这一将使用到了请求，当然要启动服务器喽
<em>$http:是对原生XMLHttpRequest对象的封装。
<b>基本使用：</b>
1) $http({url:'',method: 'get'})
  a) 返回一个promise对象，英文意思答复，允诺
  <i>omg的我的天啊  promiseA+规范，我前几天也不知道什么鬼，看到这个莫名的收藏了，现在就用到了，啊，冥冥中自有定向啊，厉害了啊。哈哈哈哈，想要的应该都在里面了</i>
  b) promise的then方法  then(sucessFn,errorFn)
  c) 简写形式: get()获取数据 post()发送数据 delete()删除 put()更新 jsonp()跨域 head()
    <i>c) :这种技术会在很流行的(restful)这样一种后台请求技术</i>
</em>


<strong>服务(4)</strong>
<em>
  包装器 decorator: $provide 通常用在配置函数config 提供了在服务实例创建时对其进行拦截的功能，可以对服务进行扩展，甚至完全替代它。
    常见使用场景
      对服务进行扩展。所有服务(内置，自定义，第三方)
      对服务封装以便开发时调试和跟踪
  使用方式：$provide.decorator(拦截服务名，fn)
  <i>p.finally() 哪里来的东西</i>
  <a>server/js/service.js</a>75-99
</em>

<strong>服务类型</strong>
<a>server/service.html</a>:provider用到了$http请求json文件，所以必须启动一个服务器
<em><b>服务类型：</b>
1) 常量 constant(name,value)
2) 变量 value(name,value)
/**
 * 声明常量和变量两种服务
 * 虽然是常量，但是还可以去更改值，
 * config优先级高于controller
 * 常量可以在程序配置函数中使用
 */
两者的区别：常量可以注入到配置函数中，因此更适合作为配置的变量来使用。跟名称常量不相符的是它的值可以修改
3) 工厂 factory(name,getFn); 工厂是创建和配置服务的最快捷方式
4) 服务 service(name,constructor);  和factory等同效果
  <a>server/js/service.js</a>
5) 提供者 provider(name,{$get:function(){}})
  当传入的函数就是$get时，factory就是provider的简化形式
  <a>server/js/service.js</a>:45
6) 包装器 decorator 避免混淆，这讲放到服务(四)里面
</em>

<strong>工厂服务</strong>
<b>服务放到新的目录server</b>
<em>
服务提供能够在应用的整个生命周期保持数据的方法，它能在控制器之间通信，且能保持数据的一致性。
特性：
1) 单例
2) 延迟加载(用的时候才会加载，而不是注入后，节约内存资源)
<b>创建一个服务 app.factory()工厂服务</b>
<a>server/server.html</a>
</em>




<strong>表单与验证五</strong>
<a>input/zidingyi.html</a>

<a>input/js/required.js</a>:39
<em>自定义验证
<i>还是新开一个HTML吧。清晰点</i>
<b>自定义的核心就是$setValidity()</b>
存在ngModel控制器里面
接下来更改的更像是一个实际案例
<i>哇哇哇哇  分开来好清晰啊。瞬间明白了哈哈</i>
但是这样写太过冗余，系统提供了一个
<b>ngMessages用于简化验证提示信息代码的编写</b>
要引入ngMessages模块，我这里单开一节进行处理，毕竟实战中要用的
<a>input/ngMessages.html</a>:24
<b>导入angular-validation 库 github下载</b>
</em>

<strong>表单验证三</strong>
<a>input/required.html</a>
<em>
  <b>表单验证：</b>
  1) angular结合HTML5表单验证、内置验证指令和自定义验证指令来实现。
  2) 验证选项
    a) 必填项 required H5
    B) 最小值 min H5
    C) 最大值 max H5
    d) 最小长度 min-length  ng-minLength="5"
    e) 最大长度 ng-maxlength="10"
    f) 模糊匹配 ng-pattern="[a-zA-Z]"
    g) 电邮 声明 type="email" 即可 H5
    h) 数字 声明 type="number" 即可 H5
    I) URL 声明 type="url"即可 H5
  3) 验证属性
    a) $pristine 未修改的表单
    b) $dirty 修改过的表单
    c) $valid 合法表单
    d) $invalid 非法的表单
    e) $error 错误对象
  4) 验证触发  表单验证四节
    a) 禁用H5原生验证：在form对象添加novalidate
    b) 失去焦点触发验证：
      i) 创建$scope.focused = false;
      ii) 使用ng-focus,ng-blur事件，修改focused状态为true或者false
      iii) scope.$apply() 这个方法是模型改变试图跟着更改
      iiii) 创建$scope.sumitted = false;提交表单时，如果$scope.form.$invalid==true,将其制为true,从而显示错误信息
  <b>相关css样式</b>
    ng-pristine  没问题
    ng-invalid  有问题
    ng-dirty
    ng-valid
    <i>可以通过这些类名进行更改，很是方便</i>

</em>

<strong>表单与验证</strong>
<a>input/form2.html</a>
<b>此部分后半讲都在其中</b>
<a>input/controlls.html</a>
<em>
  <b>表单控件：input、select、textarea</b>
  1) radio ng-value来传输数据,设置特殊的值，甚至表达式的值  //controlls.html
  2) checkbox 用到两个指令 ng-true-value 意思就是选中的时候显示的值
  3) Select:
    a) 结合ngOptions绑定模型快速生成选项列表
    b) 基本用法
      i) labelField for item in array
      ii) 分组写法 labelField group by groupField for item in array

</em>
<strong>表单与验证</strong>
<a>input/form.html</a>
<em>
  <b>表单声明</b>
  < form name="myForm" ng-controller="myFromController"></ form>
  *注意：如果声明name属性，表单控制器会被发布到name对应的作用域下
  <b>表单嵌套：</b>
  Angular中表单能够嵌套的，浏览器实际不允许，所以angular提供了ngForm指令来实现之
  <b>提交表单</b>
  1.form元素上添加ngSubmit指令并添加一个type为submit的input触发提交行为
  2.在第一个按钮或类型为submit的input字段上添加ngClick指令
  注意：为了防止处理程序的双重执行，只能使用上面两种方式的其中之一；第一种较为常用
</em>
<strong>多重试图与路由三</strong>
  <a>view/js/route.js</a>
<em>
  <b>路由配置详解：</b>
  templateUrl: 指定模板所存在的地址
  template: 指定模板html(不常用)
  controller: 控制器，设置为字符串则是当前模块中查询相对应的控制器的定义并作用域当前的试图。
  redirectTo: 如果匹配不到任何合法URL则重定向到/页面 用于otherwise的配置中，用来当匹配不到合适的地址时，跳转至指定的路径去。
  reloadOnSearch: 当url地址中的查询串发生变化的时候，是否重新的加载页面，假如设置为true,当url中的查询串(?后面的部分)发生变化，页面就重新去加载。(比如实现分页?page=3)
  resolve: 在路由发生之前获取数据,和服务端打交道，应该是这样
  <i>详细案例route.js </i>
</em>

<strong>多重视图和路由1</strong>
<i>这讲详细请看，route.js 和route.html查看详情</i>
<a>view/js/route.js</a>
<i>牵扯到路由所以此路径打开无效，必须用服务器软件开启类似端口的东西</i>
<a>view/route.html</a>
<em>
$routeProvider

  <b>这个标题相关标签列出来</b>
单页应用(SPA)中往往有多重视图，在他们之间导航称之为路由。ng-view作为视图容器
ng-view 作为视图容器
<b>路由的基本使用 route.html</b>
1) 引入angular-route>添加模块angular.module('myApp',['ngRoute'])>创建布局模板，加入ng-view作为视图容器>配置路由>使用a进行路由或者注入$location实现视图路由

<b>视图之间的路由方式：</b>
1) 使用a进行路由
2) 注入$location实现路由

为什么需要第二种方式：
为了给接下来的视图传递参数

传递参数：
1) 需要在路由配置这里配置参数设置，类似/default/:pid
2) 跳转时: $location.path('/default/1')
3) 获取参数: $routeParams.pid
<i>这讲详细请看，route.js 和route.html查看详情</i>
</em>
<strong>其他视图指令</strong>
<i>这个章节都在view里面，为了方便查找</i>
<a>view/view.html</a>
<em>
<b>前面所学汇总</b>
  ng-if/ng-show/ng-hide/ng-repeat
<b>新学</b>
1) ng-switch //条件较多使用switch，更复杂的条件控制，配合on属性/ng-switch-when/ng-switch-default
  a) view.html
2) ng-include : 包含引入的意思，实际是加载外部HTML片段到当前页面中，适合创建页面模板的时，把公用的部分提取出来，然后用ngInclude引入。
  a) view.html:15
  b) 注意: 该指令会生成子作用域，如果希望使用其他作用域，则需要明确声明一个ng-controller="myControllerA"
    i) < div ng-include="'tpl/header.html'" ng-controller="myControllerA">aaa</ div>
</em>
<strong>指令6</strong>
<a>js/directive.js</a>:128
<a>js/canvas.js</a>:34
<em>
AngularJS生命周期：
编译阶段：遍历ng-app所包含的HTML文档并根据js中指令的定义来处理页面上生命的指令。将其转换为浏览器可识别的HTML内容。
编译后会返回一个模板函数,在它被返回前，有机会对编译后的DOM树进行修改。
这个机会就在 compile里面
由于此时未进行数据绑定，操作DOM时性能开销很小，如ng-repeat和ng-transclude等内置的指令会在此时对DOM操作。
<b>编译compile directive.js:128</b>
普通用户在开发的时候很少使用
设置为函数，该选项可以返回对象或函数
<b>链接link</b>
注意：如果设置了编译函数，链接函数就会失效，可以说他们是互斥的
链接函数很常用，在这里可以进行DOM操作，

<b>$setViewValue canvas.js:34</b>
 ngModel控制器的$setViewValue(),可以动态更新视图的相关模型
</em>
<strong>指令5</strong>
<a>directive.html</a>:43
<em>
  控制器Controller
  控制器主要用于逻辑处理和控制,比如操作$scope中的模型，创建控制器的主要目的是可以吧共享的代码放在这里，供其他指令调用，设计到另外的require属性。
  <b>导入 require directive.js:100详解用法</b>
  在一个指令中可以注入其他指令的名称，因此就可以使用其控制器。
  <b>controllerAs 控制器的别名 directive.js:116</b>
  设置控制器别名以此发布控制器，且作用域可以访问controllerAs指定的别名
</em>
<strong>指令3</strong>
<b>对应案例directive.html</b>
<em>
  <b>指令详解：</b>
  指令可以使用的全部设置选项
  retrict: String,  'AECM'
  template: String or function(eElement,tAttrs){rerurn String},  //模板字符串
  repeat: boolean, //是否用模板代替指令
  priority: Number, //优先级
  terminal: Boolean, //设为true时，如果存在优先级低于当前指令的其他指令，则忽略之
  templateUrl:String,//Url字符串，指明模板文件存放地址
  scope: Boolean or Object,//作用域
  controller:String or function(scope,element,attrs,transclude),//控制器
  transclude:Boolean,//设置为true表示当前指令中可以嵌入其他内容或指令
  require:String or Array,//设置其他指令名称，可以注入这些指令控制当前指令使用
  compile://返回一个对象或者编译函数
    function(tElement,tAttrs,transclude){
      return {
        pre:function(scope,iElement,iAttrs,controller){},预处理
        post: function(scope,iElement,iAttrs,controller){} 后处理
      }
    },
  link: 设置了compile  link就不生效
    function(scope,element,attrs,ctrl){//注入require才会有ctrl

    }
<i>tElement t代表模板 iElement i代表实例</i>
<b>参数详解</b>
优先级 priority
多数指令会忽略该参数,使用其默认值0,少数指令优先级较高,如ng-repeat,优先级1000,保证其总是能够在其他指令之前执行。如果优先级相同,则在前面的先调用。

终止 terminal
设置true时,AngularJs将停止运行当前元素上比本指令优先级的指令，优先级相同的指令仍然运行。
举例
  < div ng-if="b" ng-view></ div>
  ngif优先级略高于ngview,如果b==true,ngif为true,ngView将会执行，否则ngView将不起作用。

模板template 案例位置directive.js:29 directive.html:27
1) HTML文本
2) 函数，参数为tElement何tAttrs,并返回一个代表模板的字符串。上面的t代表模板，相当于instance。
  a) 注意：
    i) 模板中科院包含表达式{{}}
    ii) 如果含有多个DOM元素，或者只有一个单独文本节点构成，那他必须包含在一个父元素中，即必须包含一个根元素

模板路径 templateUrl 案例位置directive.js:40 directive.html:31
两种使用形式：
1) 代表外部HTML文件路径的字符串
2) 函数,参数tElement和tAttrs,返回外部HTML文件字符串
注意：angular使用Ajax加载模板文件，开发时要运行一个本地服务器否则可能因长期错误
加载编译和链接函数都会暂停，如果模板数量众多或体积较大时会影响性能。 缓存机制解决

<i>第十八节指令5因为写到这里可读性较高，所以特此声明下</i>
嵌入 transclude 案例位置directive.js:62 directive.html:39
如果设置，其值必须为true，默认为false，嵌入常和作用域(scope)配合使用，创建一些可复用的组件。
<b>作用域scope</b>
1) 布尔值，默认为false,设置为true表示从父作用域继承并创建新作用域
2) 对象，创建一个隔离作用域
<b>对象,创建一个隔离作用域</b>
绑定策略补充:可以指定属性名称而不必与隔离作用域中指定的对应
@attr、=attr、&attr
</em>
<strong>指令1</strong>
<b>对应案例directive.html</b>
<em>指令-directive
已经学过的内置指令
ng-app/ng-contorller/ng-init/ng-model/ng-bind/ng-value/ng-change/ng-click/ng-repeat
<b>第一个自定义指令</b>
app.directive('myDirective',function(){
  return {
    template:....
  }
})
//命名约定：使用驼峰写法，大写字母处在使用的时候需要用'-'隔空
1). 使用指令的四种形式：
  a) 属性(A)
  b) 标签(E)element
  c) 类(C)class
  d) 注释(M)
    i) < !-- directive:my-directive -->
  注意：从浏览器的兼容方面考虑，建议使用A或E
2). replace: 替换掉指令标签，使用户看不到指令，而只能看到最终生成的DOM元素
3). 向指令中传递参数：
  a) 使用元素所属的作用域中的变量
    i) 缺点:很明显，指令对控制器产生依赖，如果控制器被移除，或者控制器中也需要这个变量名，产生命名冲突。
  b) 通过隔离作用域初始化参数

<b>使用隔离作用域</b>
1.传递布尔值，默认为false,意为不使用隔离作用域,设置为true
scope: {...}  更有意义的设置：
  a) @:可以直接从属性中获取值
  b) =:可以传递表达式
  c) &:可以传递函数(通常作为回掉函数)
    i) 这里的函数是执行的了，而且在template里面还要执行。。可以用=解决啊。搞不懂哦
</em>
<strong>第十三讲过滤器三</strong>
<em>回顾:
1). orderBy 排序
2). filter 过滤  筛选类似搜索功能
3). ng-repeat: 迭代
<b>使用js调用过滤器</b>详见table.html:81
$filter('orderBy')(array, expression, reverse)
注意事项
1) 需要依赖注入$filter
2) 排序执行以后并不改变原数组，二手返回排序后的新数组
<b>自定义过滤器</b>
过滤器属于服务(service)的一种，类似conrtoller,可以自定义实现所需的功率功能，称为自定义过滤器
定义方式如下:
详见table.html:105
</em>
<strong>第十讲过滤器1</strong>
<b>对应案例table.html:33</b>
<em>可以对输入的值按照指定的方案进行处理后再输出的函数
<b>过滤器</b>
1). 货币过滤器 {{danj2*shul2|currency}}，{{danj2*shul2|currency:'￥'}}
2). 日期过滤器:date {{new Date()|date:'yyyy-MM-dd'}}
3). 数字过滤器:number,格式化数字 {{123234.2356|number:2}}
4). limitTo: 限制长度  {{'伺服电机无二哦iu我去诶UI哦全文'|limitTo:10}} 对数组也是有用的 {{[1,2,3]|limitTo:2}}
5). lowercase 转换字符串为小写形式
6). uppercase 转换字符串为大写形式
7). filter: 从array中选择一个子集，作为一个新数组返回(详见table.html:38)
9). orderBy: 通过expression来排序指定的数组。字符串按照字母的顺序排序，数字呢按照大小排序
  a). 注意：如果你发下数组没有正确排序，请确认他们保存的是数字而不是字符串
  b). {{orderBy_expression|orderBy:expression:reverse}}
</em>
<strong>第九讲数据绑定和表达式五</strong>
<b>对应案例table.html canvas.js:37</b>
<em>$scope.$watch 是angular内置函数 预模型的观察和监控
绑定表达式可以使用$watch的方式监控
接收一个表达式...
scope.$watch('expression',function(newVal,oldVal){})
</em>
<strong>第八讲数据绑定和表达式四</strong>
<b>对应案例ngClass.html</b>
<i>此讲是第二讲的续。所以备注到了第二讲，特此说明</i>

<strong>第七讲数据绑定和表达式三</strong>
<b>对应案例ngClass.html</b>
<i>此讲是第二讲的续。所以备注到了第二讲，特此说明</i>
<strong>第六讲数据绑定和表达式二</strong>
<b>对应案例ngClass.html</b>
<em><b>变量声明,和上节总结</b>
 1). 常量{{'abc'}}
 2). 变量{{abc}}
    a). 变量声明: $scope.abc='abc';
    b). 变量声明: ng-init="" 不推荐：module和view之间产生了耦合，这种形式常用于小程序的测试和展示但不适合用于生产，不利于后期的维护重用
    c). 变量声明: ng-model
 3). 函数{{fn( )}}
 4). 表达式{{a+b}}
<b>数据绑定</b>
<i>将模型的Model 和试图 View关联起来，双方的改变都能影响到对方</i>
数据绑定类型：
1). 单项数据绑定:模型能够影响试图，反之则不行
  a) 简写形式： {{abc}}
  b) 指令形式：
    i: ng-bind=''  是简写形式的替代，最佳实践是在首页使用ng-bind形式，其他页面使用简写形式。
    ii: ng-checked: 绑定radio和checkbox这种类型表单元素和选中状态
    iii: ng-class
    iv: ng-hide/ng-show: 是否显示/隐藏HTML元素
    v: ng-if: 直接隐藏代码 和jq的appendTo()很像
    vi: ng-readonly: 是否只读
    vii: ng-selected: 是否选择，主要用于select下拉列表
    viii: ng-src: 用于设置img元素图片url
    ix: ng-value: 设置输入框的值,单向初始化值
    x: ng-style: 动态设置样式
  c) 所谓单向，model会影响view ，但view不会影响model
2). 双线数据绑定:模型和试图可以相互影响
  a) 双向数据绑定自己会声明，ng-model="username";相当于controller里面声明
  $scope.username. 厉害了
</em>
<strong>第五讲表达式和数据绑定</strong>
<em>表达式是AngularJs模板引擎的重要内容，也是视图View的必要的组成部分，用来将模型动态转换为可视的DOM元素或者其内容({{}} 这就是表达式 'Hello'常量  num 变量)

<b>表达式的形式:</b>
1).常量: {{'hello,Word'}},{{123}},{{true}},{{[1,2,3]}}
  a) 注意：使用常量的形式，不能使用对象{{{a:'aaa'}}}
2).变量(重要)： {{num}}
3).函数(重要)： {{fn()}} 函数形式
4). 表达式: {{a+b}}  {{a&&b}} {{c?'yes' : 'no'}} 三元表达式
  a). 注意：条件语句不能再表达式中使用(如：if()else{},switch,while(){} )

<b>模型声明的几种形式：</b>
<i>$scope本身是域，那么作用域对象在angular里面其实就是module的这个角色，那么我们声明模型就在Scope上面去声明变量：</i>
1). $scope.a = 'hello.world'
2). ng-init="a='s';b=123"   可以声明多个，所有数据类型都可以声明
3). ng-model 双向数据绑定

</em>

<strong>第四节控制器和作用域</strong>
<em>控制器：在angularJs中控制器是一个函数，用来向试图的作用域里面添加额外的功能(可能是函数也可能是操作数据的操作)，主要是来设置作用域的初始状态并添加自定义行为。

<b>控制器的声明：</b>
 * 定义控制器myController
 * 第一个参数是控制器的名称
 * 第二个参数是控制器的具体定义，务必添加$scope(作用域对象)
app.controller('myController',function($scope){
$scope 就是上面所说的作用域
})
<b>控制器的使用：</b>
在需要的地方(html某个标签上)添加ng-controller这个指令
<b>注意事项:</b>
1).控制器中尽量保持简洁,也就是说我们在这里面只做一件事情$scope预模型对象初始化(主要是来设置作用域的初始状态并添加自定义行为)类似add函数，num设置初始值一些自定义行为
2).尽量只和$scope打交道
3).不能做一些复杂的数据访问
4).Ajax请求
5).或者进行DOM操作(不是不可以，是官方建议，因为这样违反了mvc的架构思想，发生了数据耦合)
6).格式化，数据操作都不应该
<b>控制器嵌套：</b>
不推荐这种  好像大漠穷秋老师讲的是 server 服务
嗯，应该就是这样，哎呀呀  听那个老师听的迷的，还是这个好理解，100分

</em>

<strong>第三节模块Module</strong>
<em> *使用angular.module()创建应用程序模块
 *第一个参数是模块名称
 *第二个是依赖模块数组
<b>angular.module('Myapp',[])</b>


<b>使用模块的好处：</b>
1).保持全局命名空间的清洁
2).编写测试代码更容易
3).易于在不同的应用程序之间复用代码。也就是提高代码的复用性
</em>











































<script>
window.onload=function(){(function(){var htm=document.getElementsByTagName("body")[0];htm.innerHTML=htm.innerHTML.replace(/\n/g,"<br/>").replace(/ /g,"&nbsp;").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;").replace(/<strong>/g,"----------------------------------------<br/><br/><strong>").replace(/`/g," ")})();(function(){var htm=document.getElementsByTagName("a");for(var i=0;i<htm.length;i++){htm[i].target="_blank";htm[i].href=htm[i].innerHTML}})();(function(){var str=document.getElementsByTagName("strong");var mao=document.getElementsByTagName("ul")[0];var links=[];for(var i=0;i<str.length;i++){var strs=str[i].innerHTML.replace(/&nbsp;/g,"--");str[i].id=strs;links.push('<li><a href="#'+strs+'">'+strs+"</a></li>")}links.push('<a class="c" href="#"><u></u></a>');mao.innerHTML=links.join(" ")})();(function(){var is=document.getElementsByTagName("em");for(var i=0;i<is.length;i++){is[i].onclick=function(){if(this.style.overflow!="visible"){this.style.overflow="visible";this.style.height="auto";this.style.fontSize="20px"}else{this.style.overflow="hidden";this.style.height="29px";this.style.fontSize="13px"}}}})()};
</script>

</body>
</html>
